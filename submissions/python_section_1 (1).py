# -*- coding: utf-8 -*-
"""python_section_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n26f3f5MaFVTEhkoeBxIqF8taBN9513s

Question 1: Reverse List by N Elements
Problem Statement:

Write a function that takes a list and an integer n, and returns the list with every group of n elements reversed. If there are fewer than n elements left at the end, reverse all of them.
"""

from typing import List
def reverse_by_n_elements(lst: List[int], n: int) -> List[int]:
  output=[]

  for i in range(0,len(lst),n):
    element=[]
    for j in range(min(n,len(lst)-i)):
      element.insert(0,lst[i+j])
    output.extend(element)
  return output

# print(reverse_by_n_elements([5,6,7,8,1,2],3))
# print(reverse_by_n_elements([5,6,7,8,1,2],2))
# print(reverse_by_n_elements([5,6,7,8,1,2],4))
# print(reverse_by_n_elements([1,2,3,4,5],2))



"""Question 2: Lists & Dictionaries
Problem Statement:

Write a function that takes a list of strings and groups them by their length. The result should be a dictionary where:

The keys are the string lengths.
The values are lists of strings that have the same length as the key.

"""

from typing import Dict
def group_by_length(lst: List[str]) -> Dict[int, List[str]]:
    """
    Groups the strings by their length and returns a dictionary.
    """
    # Your code here
    length_of_dict={}
    for string in lst:
      length=len(string)  # 6
      if length not in length_of_dict:
        length_of_dict[length]=[]
        print(length_of_dict)
      length_of_dict[length].append(string)
      print(length_of_dict)

    return dict(sorted(length_of_dict.items()))

print(group_by_length(["apple", "bat", "car", "elephant", "dog", "bear"]))
print(group_by_length(["one", "two", "three", "four"]))



"""Question 3: Flatten a Nested Dictionary
You are given a nested dictionary that contains various details (including lists and sub-dictionaries). Your task is to write a Python function that flattens the dictionary such that:

Nested keys are concatenated into a single key with levels separated by a dot (.).
List elements should be referenced by their index, enclosed in square brackets (e.g., sections[0]).
"""

from typing import Dict, Any

def flatten_dict(nested_dict: Dict[str, Any], sep: str = '.') -> Dict[str, Any]:

    flattened_dict = {}

    def flatten(cdict: Dict[str, Any], parent_key: str = '') -> None:
        for key, value in cdict.items():

            new_key = f"{parent_key}{sep}{key}" if parent_key else key

            if isinstance(value, dict):
                flatten(value, new_key) # flatten it
            elif isinstance(value, list):  # If the value is a list
                for i, item in enumerate(value):
                    if isinstance(item, dict):  # If the list item is  dictionary
                        flatten(item, f"{new_key}[{i}]")  # Recurse into the dictionary
                    else:
                        flattened_dict[f"{new_key}[{i}]"] = item  # Add non-dict list items
            else:
                flattened_dict[new_key] = value  # Add the value directly

    flatten(nested_dict)
    return flattened_dict


nested_dict = {
    "road": {
        "name": "Highway 1",
        "length": 350,
        "sections": [
            {
                "id": 1,
                "condition": {
                    "pavement": "good",
                    "traffic": "moderate"
                }
            }
        ]
    }
}

flattened = flatten_dict(nested_dict)
print(flattened)



"""

Question 4: Generate Unique Permutations
Problem Statement:

You are given a list of integers that may contain duplicates. Your task is to generate all unique permutations of the list. The output should not contain any duplicate permutations.


"""

def unique_permutations(nums: List[int]) -> List[List[int]]:


    # Your code here
    def backtrack(path,used):

      if len(path)==len(nums):
        result.append(path[:])
        return
      for i in range(len(nums)): # 0 1 2
                       # nums 1 1 2
        if used[i]:    # used  T,T,T
          continue     # path=[1,1,2]
        if i>0 and nums[i]==nums[i-1] and not used[i-1]:
          continue
        used[i]=True
        path.append(nums[i])
        backtrack(path,used)
        used[i]=False
        path.pop()

    nums.sort()
    print(nums)
    result=[]
    used=[False]*len(nums)
    print(used)
    backtrack([],used)
    return result


nums=[2,1,1]
print(unique_permutations(nums))



"""question 5: Find All Dates in a Text
Problem Statement:

You are given a string that contains dates in various formats (such as "dd-mm-yyyy", "mm/dd/yyyy", "yyyy.mm.dd", etc.). Your task is to identify and return all the valid dates present in the string.
"""

import re
def find_all_dates(text: str) -> List[str]:
    patterns=[r"\b\d{2}-\d{2}-\d{4}\b",r"\b\d{2}/\d{2]/\d{4}\b",r"\b\d{4}\.\d{2}\.\d{2}\b"]
    dates=[]
    for pattern in patterns:
      dates.extend(re.findall(pattern,text))
    return dates

txt=input()
print(find_all_dates(txt))



"""Question 6: Decode Polyline, Convert to DataFrame with Distances
You are given a polyline string, which encodes a series of latitude and longitude coordinates. Polyline encoding is a method to efficiently store latitude and longitude data using fewer bytes. The Python polyline module allows you to decode this string into a list of coordinates.
"""

import pandas as pd
import numpy as np
import polyline

def haversine(lat1, lon1, lat2, lon2):
  r=6371000
  lat1rad=np.radians(lat1)
  lon1rad=np.radians(lon1)
  lat2rad=np.radians(lat2)
  lon2rad=np.radians(lon2)

  dlat=lat2rad-lat1rad
  dlon=lon2rad-lon1rad
  a=np.sin(dlat/2)**2+np.cos(lat1rad)*np.cos(lat2rad)*np.sin(dlon/2)**2
  c=2*np.arctan2(np.sqrt(a),np.sqrt(1-a))
  distance=r*c
  return distance



def polyline_to_dataframe(polyline_str: str) -> pd.DataFrame:
    coordinates=polyline.decode(polyline_str)
    df=pd.DataFrame(coordinates,columns=['latitude','longtitude'])
    distances=[0]
    for i in range(1,len(df)):
      dist=haversine(df.loc[i-1,'latitude'],df.loc[i-1,'longtitude'],df.loc[i,'latitude'],df.loc[i,'longtitude'])
      distances.append(dist)
    df['distance']=distances
    return df


ps="m~k~F~{c@_od|Hko@k~WbiA"
print(polyline_to_dataframe(ps))



"""Question 7: Matrix Rotation and Transformation
Write a function that performs the following operations on a square matrix (n x n):

Rotate the matrix by 90 degrees clockwise.
After rotation, for each element in the rotated matrix, replace it with the sum of all elements in the same row and column (in the rotated matrix), excluding itself.
The function should return the transformed matrix.
"""

def rotate_and_multiply_matrix(matrix: List[List[int]]) -> List[List[int]]:

    # Your code here
    n=len(matrix)
    rotated_matrix=[[0]*n for _ in range(n)]
    for i in range(n):
      for j in range(n):
        rotated_matrix[j][n-1-i]=matrix[i][j]

    final_matrix=[[0]*n for _ in range(n)]
    for i in range(n):
      for j in range(n):
        row_sum=sum(rotated_matrix[i])
        col_sum=sum(rotated_matrix[k][j] for k in range(n))
        final_matrix[i][j]=row_sum+col_sum-2*rotated_matrix[i][j]

    return final_matrix


matrix=[[1,2,3],[4,5,6],[7,8,9]]
result=rotate_and_multiply_matrix(matrix)
print(result)



"""Question 8: Time Check"""

pd.head()

import pandas as pd

def time_check(df: pd.DataFrame) -> pd.Series:

    weekday_to_index = {'Monday': 0, 'Tuesday': 1, 'Wednesday': 2, 'Thursday': 3, 'Friday': 4, 'Saturday': 5, 'Sunday': 6}
    df['startDayIndex'] = df['startDay'].map(weekday_to_index)
    df['endDayIndex'] = df['endDay'].map(weekday_to_index)

    grouped = df.groupby(['id', 'id_2'])

    results = {}

    for (id_val, id_2_val), group in grouped:
        # unique days covered
        unique_days = set(group['startDayIndex']).union(set(group['endDayIndex']))
        # 7 days are covered
        covers_all_days = len(unique_days) == 7

        # time coverage
        all_times_covered = (
            group['startTime'].min() <= '00:00:00' and
            group['endTime'].max() >= '23:59:59'
        )

        results[(id_val, id_2_val)] = (covers_all_days and all_times_covered)

    return pd.Series(results)



df = pd.read_csv('dataset-1.csv')
result = time_check(df)
print(result)

